# Copyright 2020 Samson Woof. All Rights Reserved.
# =============================================================================

"""Data processing tools for Segmentation.
"""

import json
from io import BytesIO
from PIL import Image
import base64
import numpy as np
import cv2
import os
import threading
import imgaug.augmenters as iaa
import threading
from math import ceil
from matplotlib.colors import to_rgb
from tensorflow.keras.utils import Sequence


def _process_img(img, size):
    size = size[1], size[0]
    zoom_r = np.array(img.size)/np.array(size)
    img = img.resize(size)
    img = img.convert("RGB")
    img = np.array(img)
    return img, zoom_r


def _str_to_rgb(c):
    if type(c)==str:
        return tuple(map(lambda x:int(round(x*255)), to_rgb(c)))
    else:
        return c


def normalize_fun(mean, std):
    def normalize(data):
        data -= mean
        data /= std
        return data
    return normalize


class Segdata_reader:
    """Read the images and annotations for segmentation.

    Args:
        rescale: A float or None,
            specifying how the image value should be scaled.
            If None, no scaled.
        preprocessing: A function of data preprocessing,
            (e.g. noralization, shape manipulation, etc.)
        augmenter: A `imgaug.augmenters.meta.Sequential` or 
            `albumentations.core.composition.Compose` instance.
        aug_times: An integer,
            The default is 1, which means no augmentation.

    Attributes:
        rescale
        preprocessing
        augmenter
        aug_times
        file_names: A list of string
            with all file names that have been read.

    Return:
        A reader instance for images and annotations.

    """
    def __init__(self, rescale=None,
                 preprocessing=None,
                 augmenter=None, aug_times=1):
        self.rescale = rescale
        self.preprocessing = preprocessing
        self.augmenter = augmenter
        self.aug_times = aug_times
        self.file_names = None

        if augmenter is None:
            self.aug_times = 1

    def labelme_json_to_dataset(
        self, img_path=None, label_path=None,
        class_names=[], size=(512, 512),
        allowed_shape_types=["polygon"],
        padding=True, line_thickness=5,
        shuffle=True, seed=None,
        classifi_mode="one",
        encoding="big5",
        slice_id=None,
        thread_num=10):
        """Convert the JSON file generated by `labelme` into ndarray.

        Args:
            img_path: A string, 
                file path of images.
                if JSON files include images,
                just specify one of args(img_path、label_path)
                with JSON files path.
            label_path: A string,
                file path of JSON files.
            class_names: A list of string,
                the class names of the category in `labelme`.
                For example: ["g", "t", "v", "bg"],
                    the format of the returned label is one-hot,
                    and the channel is the class.
                    For example, the channel is [1, 0, 0, 0, 0],
                    which means the pixel is "g";
                    [0, 0, 0, 0, 1] means Nothing.
                The following format is also acceptable:
                ["g", ("t", "v"), "bg"],
                which means to treat "t" and "v" as a group.
            size: A tuple of 2 integers: (heights, widths),
                images will be resized to this arg.
            allowed_shape_types: A list of string,
                shape types allowed to be read, default: ["polygon"].
                Valid strings: "polygon", "linestrip", "rectangle".
            padding: A boolean,
                whether to fill the mark, default: True.
            line_thickness: A integer,
                the width of the drawn line, default: 5.
            shuffle: Boolean, default: True.
            seed: An integer, random seed, default: None.
            classifi_mode: A string,
                one of 'one'、'binary'、'multi',
                which means one-hot encode、binary encode
                and multi-hot encode respectively.
            encoding: A string,
                encoding format of JSON file,
                default: "big5".
            slice_id: A tuple or None,
                slice id of img_path.
            thread_num: An integer,
                specifying the number of threads to read files.

        Return:
            A tuple of Numpy arrays: (img data, label data)
            img data:
                shape (batches, img heights, img widths, color channels).
            label data:
                shape (batches, mask heights, mask widths, classes).
        """
        return self._file_to_array(
            img_path=img_path, label_path=label_path,
            class_names=class_names, size=size,
            allowed_shape_types=allowed_shape_types,
            padding=padding, line_thickness=line_thickness,
            shuffle=shuffle, seed=seed,
            classifi_mode=classifi_mode,
            encoding=encoding,
            slice_id=slice_id,
            thread_num=thread_num, format="json")

    def imglayer_to_dataset(
        self, img_path=None, label_path=None,
        class_colors=["r", "b"],
        size=(512, 512), shuffle=True, seed=None,
        classifi_mode="one",
        slice_id=None,
        thread_num=10):
        """Convert the images and image layers into ndarray.

        Args:
            img_path: A string, 
                file path of images.
                Or specify one of args(img_path、label_path)
                with a folder path includes images folder(should name as img)
                and masks folder(should name as label).
            label_path: A string,
                file path of segmentation masks.
            class_colors: A list of color string or RGB tuple of integer,
                Example of color string:
                    ['r', 'b'](Default).
                    check for more info about color string
                    by the following url:
                    https://matplotlib.org/tutorials/colors/colors.html
                Example of RGB tuple of integer:
                    [(255, 0, 0), (0, 0, 255)](which means Red、Blue).
            size: A tuple of integer: (heights, widths),
                images will be resized to this arg.
            shuffle: A boolean, default: True.
            seed: An integer, random seed, default: None.
            classifi_mode: A string,
                one of 'one'、'binary'、'multi',
                which means one-hot encode、binary encode
                and multi-hot encode respectively.
            slice_id: A tuple or None,
                slice id of img_path.
            thread_num: An integer,
                specifying the number of threads to read files.

        Return:
            A tuple of Numpy arrays: (img data, label data)
            img data:
                shape (batches, img heights, img widths, color channels).
            label data:
                shape (batches, mask heights, mask widths, classes).
        """
        return self._file_to_array(
            img_path=img_path, label_path=label_path,
            class_names=class_colors, size=size,
            allowed_shape_types=None,
            padding=None, line_thickness=None,
            shuffle=shuffle, seed=seed,
            classifi_mode=classifi_mode,
            encoding=None,
            slice_id=slice_id,
            thread_num=thread_num, format="layer")

    def _process_paths(self, path_list):
        path_list = np.array(path_list)
        U_num = path_list.dtype.itemsize//4 + 5
        dtype = "<U" + str(U_num)
        filepaths = np.empty((len(path_list),
                             self.aug_times),
                             dtype = dtype)
        filepaths[:, 0] = path_list
        filepaths[:, 1:] = np.char.add(filepaths[:, 0:1], "(aug)")
        path_list = filepaths.flatten()
        return path_list

    def _file_to_array(self, img_path, label_path,
                       class_names,
                       size, allowed_shape_types,
                       padding, line_thickness,
                       shuffle, seed,
                       classifi_mode,
                       encoding,
                       slice_id,
                       thread_num, format):
        if padding:
            polyline_thickness = cv2.FILLED
        else:
            polyline_thickness = line_thickness
        def _imgaug_to_array(img, label, pos):
            if self.augmenter is not None:
                if type(self.augmenter) is iaa.meta.Sequential:
                    label = np.expand_dims(label, axis=0)
                    for aug_i in range(1, self.aug_times):
                        img_aug, label_aug = self.augmenter(
                            image=img,
                            segmentation_maps=label)
                        img_data[pos + aug_i] = img_aug
                        label_data[pos + aug_i] = label_aug[0]
                else:
                    for aug_i in range(1, self.aug_times):
                        aug_sample = self.augmenter(
                            image=img,
                            mask=label)
                        img_aug = aug_sample['image']
                        label_aug = aug_sample['mask']
                        img_data[pos + aug_i] = img_aug
                        label_data[pos + aug_i] = label_aug
                
        def _read_json(_path_list, _pos):
            for path_i, name in enumerate(_path_list):
                pos = (_pos + path_i)*self.aug_times

                with open(os.path.join(
                        label_path,
                        name[:name.rfind(".")] + ".json"),
                        encoding=encoding) as f:
                    jdata = f.read()
                    data = json.loads(jdata)

                if img_path is None:
                    img64 = data['imageData']
                    img = Image.open(BytesIO(base64.b64decode(img64)))
                else:
                    img = Image.open(os.path.join(img_path, name))

                img, zoom_r = _process_img(img, size)
            
                data_shapes = data['shapes']
                for data_i in range(len(data_shapes)):
                    label_name = data_shapes[data_i]["label"]
                    shape_type = data_shapes[data_i]["shape_type"]

                    if shape_type in allowed_shape_types:
                        if label_name in class_names:
                            index = class_names.index(label_name)
                        else:
                            for key_i, key in enumerate(class_names):
                                if isinstance(key, tuple):
                                    if label_name in key:
                                        index = key_i
                                        break
                            else:
                                index = -1

                        if index >= 0:
                            points = np.array(data_shapes[data_i]["points"])
                            points = (points/zoom_r).astype(int)

                            label_im = np.zeros((*size, 1), dtype=int)
                            
                            if shape_type == "linestrip":
                                cv2.polylines(label_im,
                                              [points], False,
                                              (1, 0, 0), line_thickness)
                            elif shape_type == "polygon":
                                cv2.drawContours(label_im,
                                                 [points], -1,
                                                 (1, 0, 0), polyline_thickness)
                            elif shape_type == "rectangle":
                                cv2.rectangle(label_im,
                                              points[0], points[1],
                                              (1, 0, 0), polyline_thickness)
                            else:
                                raise ValueError(
                                    "Invalid shape type: %s" % shape_type)

                            label_shape = label_im.astype(bool)
                            label_data[pos][..., index:index + 1][label_shape] = 1
                            if classifi_mode == "one":
                                label_data[pos][..., -1:][label_shape] = 0
                label = label_data[pos].astype("int8")
                img_data[pos] = img

                _imgaug_to_array(img, label, pos)

        def _read_layer(_path_list, _pos):
            for i,  name in enumerate(_path_list):
                pos = (_pos + i)*self.aug_times

                try:
                    label = Image.open(os.path.join(
                        label_path,
                        name[:name.rfind(".")] + ".png"))
                except:
                    label = Image.open(os.path.join(
                        label_path,
                        name[:name.rfind(".")] + ".jpg"))  

                label, _ = _process_img(label, size)

                img = Image.open(os.path.join(img_path, name))
                img, _ = _process_img(img, size)

                for color_i, color in enumerate(class_colors):
                    mask = (label == color).all(axis=-1)
                    if classifi_mode == "one":
                        label_data[pos][mask, -1] = 0
                    label_data[pos][mask, color_i] = 1
                label = label_data[pos].astype("int8")
                img_data[pos] = img
                
                _imgaug_to_array(img, label, pos)

        if label_path is None:
            img_path, label_path = None, img_path

        if format == "json":
            if img_path is None:
                file_path = label_path
            else:
                file_path = img_path
            thread_func = _read_json         
        elif format == "layer":
            if img_path is None:
                img_path = label_path + os.sep + "img"
                label_path = label_path + os.sep + "label"
            file_path = img_path
            thread_func = _read_layer
            class_colors = list(map(_str_to_rgb, class_names))
        
        path_list = os.listdir(file_path)
        path_list = [f for f in path_list if not f.startswith(".")]
        if slice_id is not None:
            path_list = path_list[slice(*slice_id)]
        len_path_list = len(path_list)

        img_data = np.empty((len_path_list*self.aug_times, *size, 3))
        if classifi_mode == "one":
            label_data = np.zeros((len_path_list*self.aug_times,
                                  *size, len(class_names) + 1))
            label_data[..., -1] = 1
        else:
            label_data = np.zeros((len_path_list*self.aug_times,
                                   *size, len(class_names)))

        threads = []
        workers = ceil(len_path_list/thread_num)

        for worker_i in range(0, len_path_list, workers):
            threads.append(
                threading.Thread(target=thread_func,
                args=(path_list[worker_i : worker_i+workers],
                      worker_i)))
        for thread in threads:
            thread.start()                
        for thread in threads:
            thread.join()

        if self.rescale is not None:
            img_data = img_data*self.rescale
        if self.preprocessing is not None:
            img_data = self.preprocessing(img_data)

        path_list = self._process_paths(path_list)

        if shuffle:
            if seed is not None:
                np.random.seed(seed)
            shuffle_index = np.arange(len(img_data))
            np.random.shuffle(shuffle_index)
            img_data = img_data[shuffle_index]
            label_data = label_data[shuffle_index]
            path_list = path_list[shuffle_index]
            
        path_list = path_list.tolist()
        self.file_names = path_list

        return img_data, label_data

    def labelme_json_to_sequence(
        self, img_path=None, label_path=None,
        batch_size=20,
        class_names=[], size=(512, 512),
        allowed_shape_types=["polygon"],
        padding=True, line_thickness=5,
        shuffle=True, seed=None,
        classifi_mode="one",
        encoding="big5", thread_num=1):
        """Convert the JSON file generated by `labelme` into a Sequence.

        Args:
            img_path: A string, 
                file path of images.
                if JSON files include images,
                just specify one of args(img_path、label_path)
                with JSON files path.
            label_path: A string,
                file path of JSON files.
            batch_size: An integer,
                size of the batches of data (default: 20).
            class_names: A list of string,
                the class names of the category in `labelme`.
                For example: ["g", "t", "v", "bg"],
                    the format of the returned label is one-hot,
                    and the channel is the class.
                    For example, the channel is [1, 0, 0, 0, 0],
                    which means the pixel is "g";
                    [0, 0, 0, 0, 1] means Nothing.
                The following format is also acceptable:
                ["g", ("t", "v"), "bg"],
                which means to treat "t" and "v" as a group.
            size: A tuple of 2 integers: (heights, widths),
                images will be resized to this arg.
            allowed_shape_types: A list of string,
                shape types allowed to be read, default: ["polygon"].
                Valid strings: "polygon", "linestrip", "rectangle".
            padding: A boolean,
                whether to fill the mark, default: True.
            line_thickness: A integer,
                the width of the drawn line, default: 5.
            shuffle: Boolean, default: True.
            seed: An integer, random seed, default: None.
            classifi_mode: A string,
                one of 'one'、'binary'、'multi',
                which means one-hot encode、binary encode
                and multi-hot encode respectively.
            encoding: A string,
                encoding format of JSON file,
                default: "big5".
            thread_num: An integer,
                specifying the number of threads to read files.

        Return:
            A tf.Sequence: 
                Sequence[i]: (img data, label data)
                img data:
                    shape (batches, img heights, img widths, color channels).
                label data:
                    shape (batches, mask heights, mask widths, classes).
        """
        seq = SegDataSequence(
            img_path=img_path, label_path=label_path,
            batch_size=batch_size,
            class_names=class_names, size=size,
            allowed_shape_types=allowed_shape_types,
            rescale=self.rescale,
            preprocessing=self.preprocessing,
            augmenter=self.augmenter,
            padding=padding, line_thickness=line_thickness,
            shuffle=shuffle, seed=seed,
            classifi_mode=classifi_mode,
            encoding=encoding,
            thread_num=thread_num,
            format="json")
        self.file_names = seq.path_list

        return seq

    def imglayer_to_sequence(
        self, img_path=None, label_path=None,
        batch_size=20,
        class_colors=["r", "b"],
        size=(512, 512), shuffle=True, seed=None,
        classifi_mode="one", thread_num=1):
        """Convert the images and image layers into a Sequence.

        Args:
            img_path: A string, 
                file path of images.
                Or specify one of args(img_path、label_path)
                with a folder path includes images folder(should name as img)
                and masks folder(should name as label).
            label_path: A string,
                file path of segmentation masks.
            batch_size:  An integer,
                size of the batches of data (default: 20).
            class_colors: A list of color string or RGB tuple of integer,
                Example of color string:
                    ['r', 'b'](Default).
                    check for more info about color string
                    by the following url:
                    https://matplotlib.org/tutorials/colors/colors.html
                Example of RGB tuple of integer:
                    [(255, 0, 0), (0, 0, 255)](which means Red、Blue).
            size: A tuple of integer: (heights, widths),
                images will be resized to this arg.
            shuffle: A boolean, default: True.
            seed: An integer, random seed, default: None.
            classifi_mode: A string,
                one of 'one'、'binary'、'multi',
                which means one-hot encode、binary encode
                and multi-hot encode respectively.
            thread_num: An integer,
                specifying the number of threads to read files.

        Return:
            A tf.Sequence: 
                Sequence[i]: (img data, label data)
                img data:
                    shape (batches, img heights, img widths, color channels).
                label data:
                    shape (batches, mask heights, mask widths, classes).
        """
        seq = SegDataSequence(
            img_path=img_path, label_path=label_path,
            batch_size=batch_size,
            class_names=class_colors, size=size,
            allowed_shape_types=None,
            rescale=self.rescale,
            preprocessing=self.preprocessing,
            augmenter=self.augmenter,
            padding=None, line_thickness=None,
            shuffle=shuffle, seed=seed,
            classifi_mode=classifi_mode,
            encoding=None,
            thread_num=thread_num,
            format="layer")
        self.file_names = seq.path_list

        return seq


class SegDataSequence(Sequence):

    def __init__(self, img_path=None,
                 label_path=None,
                 batch_size=20,
                 class_names=[],
                 size=(512, 512),
                 allowed_shape_types=["polygon"],
                 rescale=None,
                 preprocessing=None,
                 augmenter=None,
                 padding=None,
                 line_thickness=None,
                 shuffle=True,
                 seed=None,
                 classifi_mode="one",
                 encoding="big5",
                 thread_num=1,
                 format="json"):
        self.batch_size = batch_size
        self.class_names = class_names
        self.size = size
        self.allowed_shape_types = allowed_shape_types
        self.rescale = rescale
        self.preprocessing = preprocessing
        self.augmenter = augmenter
        self.padding = padding
        self.line_thickness = line_thickness
        self.shuffle = shuffle
        self.seed = seed
        self.classifi_mode = classifi_mode
        self.encoding = encoding
        self.thread_num = thread_num
        self.format = format

        if padding:
            self.polyline_thickness = cv2.FILLED
        else:
            self.polyline_thickness = line_thickness
        
        if label_path is None:
            img_path, label_path = None, img_path

        if format == "json":
            if img_path is None:
                file_path = label_path
            else:
                file_path = img_path
        elif format == "layer":
            if img_path is None:
                img_path = label_path + os.sep + "img"
                label_path = label_path + os.sep + "label"
            file_path = img_path
            self.class_colors = list(map(_str_to_rgb, class_names))
        
        path_list = os.listdir(file_path)
        self.path_list = [f for f in path_list if not f.startswith(".")]
        self.img_path = img_path
        self.label_path = label_path
        if shuffle:
            if seed is not None:
                np.random.seed(seed)
            self.path_list = np.array(self.path_list)
            np.random.shuffle(self.path_list)
            self.path_list = self.path_list.tolist()

    def __len__(self):
        return ceil(len(self.path_list)/self.batch_size)

    def __getitem__(self, idx):
        if idx >= self.__len__():
            raise IndexError("Sequence index out of range")   
        def _imgaug_to_array(img, label, pos):
            if self.augmenter is None:
                img_data[pos] = img
                label_data[pos] = label
            else:
                if type(self.augmenter) is iaa.meta.Sequential:
                    label = np.expand_dims(label, axis=0)
                    img_aug, label_aug = self.augmenter(
                        image=img,
                        segmentation_maps=label)
                    label_aug = label_aug[0]
                else:
                    aug_sample = self.augmenter(
                        image=img,
                        mask=label)
                    img_aug = aug_sample['image']
                    label_aug = aug_sample['mask']
                img_data[pos] = img_aug
                label_data[pos] = label_aug

        def _read_json(_path_list, _pos):
            for i, name in enumerate(_path_list):
                pos = _pos + i
                with open(os.path.join(
                          self.label_path,
                          name[:name.rfind(".")] + ".json"),
                          encoding=self.encoding) as f:
                    jdata = f.read()
                    data = json.loads(jdata)

                if self.img_path is None:
                    img64 = data['imageData']
                    img = Image.open(BytesIO(base64.b64decode(img64)))
                else:
                    img = Image.open(os.path.join(self.img_path, name))

                img, zoom_r = _process_img(img, self.size)

                y = label_data[pos].astype("int8")
            
                data_shapes = data["shapes"]
                for data_i in range(len(data_shapes)):
                    label_name = data_shapes[data_i]["label"]
                    shape_type = data_shapes[data_i]["shape_type"]

                    if shape_type in self.allowed_shape_types:
                        if label_name in self.class_names:
                            index = self.class_names.index(label_name)
                        else:
                            for key_i, key in enumerate(self.class_names):
                                if isinstance(key, tuple):
                                    if label_name in key:
                                        index = key_i
                                        break
                            else:
                                index = -1

                        if index >= 0:
                            points = np.array(data_shapes[data_i]["points"])
                            points = (points/zoom_r).astype(int)

                            label_im = np.zeros((*self.size, 1), dtype=int)
                            
                            if shape_type == "linestrip":
                                cv2.polylines(label_im,
                                              [points], False,
                                              (1, 0, 0), self.line_thickness)
                            elif shape_type == "polygon":
                                cv2.drawContours(label_im,
                                                 [points], -1,
                                                 (1, 0, 0), self.polyline_thickness)
                            elif shape_type == "rectangle":
                                cv2.rectangle(label_im,
                                              points[0], points[1],
                                              (1, 0, 0), self.polyline_thickness)
                            else:
                                raise ValueError(
                                    "Invalid shape type: %s" % shape_type)

                            label_shape = label_im.astype(bool)
                            y[..., index:index + 1][label_shape] = 1   
                            if self.classifi_mode == "one":
                                y[..., -1:][label_shape] = 0
                
                _imgaug_to_array(img, y, pos)

        def _read_layer(_path_list, _pos):
            for i, name in enumerate(_path_list):
                pos = (_pos + i)
                try:
                    label = Image.open(os.path.join(
                        self.label_path,
                        name[:name.rfind(".")] + ".png"))
                except:
                    label = Image.open(os.path.join(
                        self.label_path,
                        name[:name.rfind(".")] + ".jpg"))  

                label, _ = _process_img(label, self.size)
                
                img = Image.open(os.path.join(self.img_path, name))
                img, _ = _process_img(img, self.size)

                y = label_data[pos].astype("int8")

                for color_i, color in enumerate(self.class_colors):
                    mask = (label == color).all(axis=-1)
                    if self.classifi_mode == "one":
                        y[mask, -1] = 0
                    y[mask, color_i] = 1
    
                _imgaug_to_array(img, y, pos)

        total_len = len(self.path_list)
        if (idx + 1)*self.batch_size > total_len:
            batch_size = total_len % self.batch_size
        else:
            batch_size = self.batch_size

        img_data = np.empty((batch_size, *self.size, 3))
        if self.classifi_mode == "one":
            label_data = np.zeros((batch_size,
                                  *self.size, len(self.class_names) + 1))
            label_data[..., -1] = 1
        else:
            label_data = np.zeros((batch_size,
                                   *self.size, len(self.class_names)))

        start_idx = idx*self.batch_size
        end_idx = (idx + 1)*self.batch_size
        path_list = self.path_list[start_idx:end_idx]
        if self.format == "json":
            thread_func = _read_json
        elif self.format == "layer":
            thread_func = _read_layer

        threads = []
        workers = ceil(len(path_list)/self.thread_num)

        for worker_i in range(0, len(path_list), workers):
            threads.append(
                threading.Thread(target=thread_func,
                args=(path_list[worker_i : worker_i+workers],
                      worker_i)))
        for thread in threads:
            thread.start()                
        for thread in threads:
            thread.join()

        if self.rescale is not None:
            img_data = img_data*self.rescale
        if self.preprocessing is not None:
            img_data = self.preprocessing(img_data)
 
        return img_data, label_data


def read_img(path, size=(512, 512), rescale=None, preprocessing=None):
    """Read images as ndarray.

    Args:
        path: A string, path of images.
        size: A tuple of 2 integers,
            (heights, widths).
        rescale: A float or None,
            specifying how the image value should be scaled.
            If None, no scaled.
        preprocessing: A function of data preprocessing,
            (e.g. noralization, shape manipulation, etc.)
    """
    img_list = [f for f in os.listdir(path) if not f.startswith(".")]
    data = np.empty((len(img_list), *size, 3))
    size = size[1], size[0]

    for img_i, _path in enumerate(img_list):
        img = Image.open(path + os.sep + _path)
        img = img.resize(size)
        img = img.convert("RGB")  
        img = np.array(img)
        data[img_i] = img

    if rescale:
        data = data*rescale
    if preprocessing is not None:
        data = preprocessing(data)
        
    return data